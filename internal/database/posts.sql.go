// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (user_id,media_type,media_hash)
VALUES ($1,$2,$3)
RETURNING id, user_id, comment, media_hash, media_type, media_url, thumb_url, status, created_at, updated_at
`

type CreatePostParams struct {
	UserID    int64  `json:"user_id"`
	MediaType string `json:"media_type"`
	MediaHash string `json:"media_hash"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.UserID, arg.MediaType, arg.MediaHash)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Comment,
		&i.MediaHash,
		&i.MediaType,
		&i.MediaUrl,
		&i.ThumbUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingPosts = `-- name: GetPendingPosts :many
SELECT id, user_id, comment, media_hash, media_type, media_url, thumb_url, status, created_at, updated_at FROM posts
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingPosts(ctx context.Context, limit int32) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPendingPosts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Comment,
			&i.MediaHash,
			&i.MediaType,
			&i.MediaUrl,
			&i.ThumbUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostByID = `-- name: GetPostByID :one
SELECT p.id, p.user_id, p.comment, p.media_hash, p.media_type, p.media_url, p.thumb_url, p.status, p.created_at, p.updated_at, u.username as author_name
FROM posts p
JOIN users u ON p.user_id = u.id
WHERE p.id = $1
`

type GetPostByIDRow struct {
	ID         int64            `json:"id"`
	UserID     int64            `json:"user_id"`
	Comment    pgtype.Text      `json:"comment"`
	MediaHash  string           `json:"media_hash"`
	MediaType  string           `json:"media_type"`
	MediaUrl   pgtype.Text      `json:"media_url"`
	ThumbUrl   pgtype.Text      `json:"thumb_url"`
	Status     PostStatus       `json:"status"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
	AuthorName string           `json:"author_name"`
}

func (q *Queries) GetPostByID(ctx context.Context, id int64) (GetPostByIDRow, error) {
	row := q.db.QueryRow(ctx, getPostByID, id)
	var i GetPostByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Comment,
		&i.MediaHash,
		&i.MediaType,
		&i.MediaUrl,
		&i.ThumbUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorName,
	)
	return i, err
}

const getPostsByUserID = `-- name: GetPostsByUserID :many
SELECT id, user_id, comment, media_hash, media_type, media_url, thumb_url, status, created_at, updated_at FROM posts
WHERE user_id = $1 AND status = 'completed'
ORDER BY created_at DESC
LIMIT $2
`

type GetPostsByUserIDParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) GetPostsByUserID(ctx context.Context, arg GetPostsByUserIDParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Comment,
			&i.MediaHash,
			&i.MediaType,
			&i.MediaUrl,
			&i.ThumbUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessingPosts = `-- name: GetProcessingPosts :many
SELECT id, user_id, comment, media_hash, media_type, media_url, thumb_url, status, created_at, updated_at FROM posts
WHERE status = 'processing'
AND updated_at < NOW() - INTERVAL '30 minutes'
ORDER BY updated_at ASC
`

func (q *Queries) GetProcessingPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getProcessingPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Comment,
			&i.MediaHash,
			&i.MediaType,
			&i.MediaUrl,
			&i.ThumbUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsWithTags = `-- name: ListPostsWithTags :many
SELECT
    p.id,
    p.comment,
    p.media_url,
    p.thumb_url,
    p.status,
    u.username AS author_name,
    COALESCE(
        json_agg(
            json_build_object('id', t.id, 'name', t.name)
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) AS tags
FROM posts p
JOIN users u ON p.user_id = u.id
LEFT JOIN post_tags pt ON p.id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.id
WHERE p.status = 'completed'
  AND p.created_at < $1  -- cursor: último created_at da página anterior
GROUP BY p.id, u.username, p.created_at
ORDER BY p.created_at DESC
LIMIT $2
`

type ListPostsWithTagsParams struct {
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Limit     int32            `json:"limit"`
}

type ListPostsWithTagsRow struct {
	ID         int64       `json:"id"`
	Comment    pgtype.Text `json:"comment"`
	MediaUrl   pgtype.Text `json:"media_url"`
	ThumbUrl   pgtype.Text `json:"thumb_url"`
	Status     PostStatus  `json:"status"`
	AuthorName string      `json:"author_name"`
	Tags       interface{} `json:"tags"`
}

func (q *Queries) ListPostsWithTags(ctx context.Context, arg ListPostsWithTagsParams) ([]ListPostsWithTagsRow, error) {
	rows, err := q.db.Query(ctx, listPostsWithTags, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsWithTagsRow
	for rows.Next() {
		var i ListPostsWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Comment,
			&i.MediaUrl,
			&i.ThumbUrl,
			&i.Status,
			&i.AuthorName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostMedia = `-- name: UpdatePostMedia :exec
UPDATE posts
SET media_url = $2, 
    thumb_url = $3,
    status = $4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdatePostMediaParams struct {
	ID       int64       `json:"id"`
	MediaUrl pgtype.Text `json:"media_url"`
	ThumbUrl pgtype.Text `json:"thumb_url"`
	Status   PostStatus  `json:"status"`
}

func (q *Queries) UpdatePostMedia(ctx context.Context, arg UpdatePostMediaParams) error {
	_, err := q.db.Exec(ctx, updatePostMedia,
		arg.ID,
		arg.MediaUrl,
		arg.ThumbUrl,
		arg.Status,
	)
	return err
}

const updatePostProgress = `-- name: UpdatePostProgress :exec
UPDATE posts
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND status = 'processing'
`

type UpdatePostProgressParams struct {
	Status PostStatus `json:"status"`
	ID     int64      `json:"id"`
}

func (q *Queries) UpdatePostProgress(ctx context.Context, arg UpdatePostProgressParams) error {
	_, err := q.db.Exec(ctx, updatePostProgress, arg.Status, arg.ID)
	return err
}
