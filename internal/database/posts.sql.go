// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPost = `-- name: CreatePost :one
INSERT INTO posts (user_id,media_type,media_hash)
VALUES ($1,$2,$3)
RETURNING id, user_id, comment, media_hash, media_type, media_url, thumb_url, status, created_at, updated_at
`

type CreatePostParams struct {
	UserID    int64  `json:"user_id"`
	MediaType string `json:"media_type"`
	MediaHash string `json:"media_hash"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost, arg.UserID, arg.MediaType, arg.MediaHash)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Comment,
		&i.MediaHash,
		&i.MediaType,
		&i.MediaUrl,
		&i.ThumbUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPostsWithTags = `-- name: ListPostsWithTags :many
SELECT
    p.id,
    p.comment,
    p.media_url,
    p.thumb_url,
    p.status,
    u.username AS author_name,
    COALESCE(
        json_agg(
            json_build_object('id', t.id, 'name', t.name)
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) AS tags
FROM posts p
JOIN users u ON p.user_id = u.id
LEFT JOIN post_tags pt ON p.id = pt.post_id
LEFT JOIN tags t ON pt.tag_id = t.id
WHERE p.status = 'completed'
  AND p.created_at < $1  -- cursor: último created_at da página anterior
GROUP BY p.id, u.username, p.created_at
ORDER BY p.created_at DESC
LIMIT $2
`

type ListPostsWithTagsParams struct {
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Limit     int32            `json:"limit"`
}

type ListPostsWithTagsRow struct {
	ID         int64       `json:"id"`
	Comment    pgtype.Text `json:"comment"`
	MediaUrl   pgtype.Text `json:"media_url"`
	ThumbUrl   pgtype.Text `json:"thumb_url"`
	Status     PostStatus  `json:"status"`
	AuthorName string      `json:"author_name"`
	Tags       interface{} `json:"tags"`
}

func (q *Queries) ListPostsWithTags(ctx context.Context, arg ListPostsWithTagsParams) ([]ListPostsWithTagsRow, error) {
	rows, err := q.db.Query(ctx, listPostsWithTags, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsWithTagsRow
	for rows.Next() {
		var i ListPostsWithTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Comment,
			&i.MediaUrl,
			&i.ThumbUrl,
			&i.Status,
			&i.AuthorName,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updataPostProgress = `-- name: UpdataPostProgress :exec
UPDATE posts
SET status = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2 AND status = 'processing'
`

type UpdataPostProgressParams struct {
	Status PostStatus `json:"status"`
	ID     int64      `json:"id"`
}

func (q *Queries) UpdataPostProgress(ctx context.Context, arg UpdataPostProgressParams) error {
	_, err := q.db.Exec(ctx, updataPostProgress, arg.Status, arg.ID)
	return err
}
